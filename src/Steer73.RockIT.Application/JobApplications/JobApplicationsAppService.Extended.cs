using DinkToPdf.Contracts;
using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.Logging;
using Steer73.RockIT.Domain.External;
using Steer73.RockIT.EzekiaSyncLogs;
using Steer73.RockIT.Enums;
using Steer73.RockIT.Extensions;
using Steer73.RockIT.FormDefinitions;
using Steer73.RockIT.Permissions;
using Steer73.RockIT.Templates;
using Steer73.RockIT.Templates.Dtos;
using Steer73.RockIT.Vacancies;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Volo.Abp;
using Volo.Abp.BlobStoring;
using Volo.Abp.Caching;
using Volo.Abp.Content;
using Volo.Abp.Data;
using Volo.Abp.Domain.Entities;
using Volo.Abp.Domain.Repositories;
using Volo.Abp.Emailing;
using Volo.Abp.TextTemplating;
using Volo.Abp.Uow;

namespace Steer73.RockIT.JobApplications
{
	public class JobApplicationsAppService : JobApplicationsAppServiceBase, IJobApplicationsAppService
    {
        protected readonly IRepository<Steer73.RockIT.Companies.Company, Guid> _companyRepository;
        protected readonly IUnitOfWorkManager _unitOfWorkManager;
        protected readonly ILogger<JobApplicationsAppService> _logger;
        protected readonly IEmailSender _emailSender;
        protected readonly IReadOnlyRepository<FormDefinition, Guid> _formDefinitionRepository;
        protected readonly ITemplateRenderer _templateRenderer;
        protected readonly IConverter _htmlToPdfConverter;
		protected readonly Lazy<JsonSerializerOptions> _jsonSerializerOptions;
        protected readonly ILogger<JobApplicationsAppService> logger;
        protected readonly IExternalCompanyService _externalCompanyService;

		//<suite-custom-code-autogenerated>
		public JobApplicationsAppService(
            IJobApplicationRepository jobApplicationRepository,
            JobApplicationManager jobApplicationManager,
            IDistributedCache<JobApplicationDownloadTokenCacheItem, string> downloadTokenCache,
            IRepository<AppFileDescriptors.AppFileDescriptor, Guid> appFileDescriptorRepository,
            IBlobContainer<JobApplicationFileContainer> blobContainer,
            IRepository<Steer73.RockIT.Vacancies.Vacancy, Guid> vacancyRepository,
            IRepository<Steer73.RockIT.Companies.Company, Guid> companyRepository,
            IUnitOfWorkManager unitOfWorkManager,
            ILogger<JobApplicationsAppService> logger,
            IBlobContainer<JobApplicantContainer> jobApplicantContainer,
            IEmailSender emailSender,
            IReadOnlyRepository<FormDefinition, Guid> formDefinitionRepository,
            ITemplateRenderer templateRenderer,
            IConverter htmlToPdfConverter,
            IExternalCompanyService externalCompanyService)
            : base(
                  jobApplicationRepository,
                  jobApplicationManager,
                  downloadTokenCache,
                  appFileDescriptorRepository,
                  blobContainer,
                  vacancyRepository,
                  jobApplicantContainer)
        {
            _companyRepository = companyRepository;
            _unitOfWorkManager = unitOfWorkManager;
            _logger = logger;
            _emailSender = emailSender;
            _formDefinitionRepository = formDefinitionRepository;
            _templateRenderer = templateRenderer;
            _htmlToPdfConverter = htmlToPdfConverter;
			_jsonSerializerOptions = new Lazy<JsonSerializerOptions>(CreateSerializerOptions);
            _externalCompanyService = externalCompanyService;
		}
        //</suite-custom-code-autogenerated>

        [AllowAnonymous]
        public async Task<JobApplicationDto> CreateNewJobApplicationCompleteAsync(NewJobApplicationCompleteDto input)
        {
            var vacancy = await _vacancyRepository.GetAsync(input.VacancyId);

            var jobApplication = ObjectMapper.Map<NewJobApplicationCompleteDto, NewJobApplicationComplete>(input);

            if (input.FileCv is not null)
            {
                jobApplication.CVUrl = $"{jobApplication.VacancyId}/{JobFileType.CV}_{Guid.NewGuid()}{Path.GetExtension(input.FileCv.Name)}";
                await _jobApplicantContainer.SaveAsync(jobApplication.CVUrl, input.FileCv.Content);
            }

            if (input.FileCoverLetter is not null)
            {
                jobApplication.CoverLetterUrl = $"{jobApplication.VacancyId}/{JobFileType.CoverLetter}_{Guid.NewGuid()}{Path.GetExtension(input.FileCoverLetter.Name)}";
                await _jobApplicantContainer.SaveAsync(jobApplication.CoverLetterUrl, input.FileCoverLetter.Content);                
            }

            if (input.FileAdditionalDoc is not null)
            {
                jobApplication.AdditionalDocumentUrl = $"{jobApplication.VacancyId}/{JobFileType.AdditionalDoc}_{Guid.NewGuid()}{Path.GetExtension(input.FileAdditionalDoc.Name)}";
                await _jobApplicantContainer.SaveAsync(jobApplication.AdditionalDocumentUrl, input.FileAdditionalDoc.Content);                
            }
           
            if (!string.IsNullOrWhiteSpace(input.JobFormResponse))
            {
                jobApplication.ResponseUrl = await GetResponseUrl(
                    vacancy,
                    input.JobFormResponse);
            }
           
            var newJobApplication = await _jobApplicationManager.CreateNewJobApplicationCompleteAsync(jobApplication);

            return ObjectMapper.Map<JobApplication, JobApplicationDto>(newJobApplication);
        }

        [Authorize(RockITSharedPermissions.JobApplications.Edit)]
        public virtual async Task ApproveAsync(Guid id, CancellationToken cancellationToken = default)
		{
			var jobApplication = await _jobApplicationRepository.GetAsync(id: id, cancellationToken: cancellationToken);

			if (jobApplication.Status != Enums.JobApplicationStatus.Pending)
			{
				return;
			}

			await Approve(jobApplication, null, cancellationToken);
		}

		[Authorize(RockITSharedPermissions.JobApplications.Edit)]
		public virtual async Task ApproveManyAsync(
			List<SelectedJobApplicationDto> jobApplicationDtos,
			CancellationToken cancellationToken = default)
		{
            if (jobApplicationDtos.Count == 0) { return; }

			var jobApplicationIds = jobApplicationDtos
                .DistinctBy(j => j.Id)
                .Select(j => j.Id)
                .ToList();

			var jobApplications = (await _jobApplicationRepository.GetListAsync(
				j => jobApplicationIds.Contains(j.Id)
					 && j.Status == JobApplicationStatus.Pending,
				cancellationToken: cancellationToken))
                .ToDictionary(j => j.Id);
			if (jobApplications.Count == 0) { return; }

			foreach (var jobApplicationDto in jobApplicationDtos)
			{
				jobApplications.TryGetValue(jobApplicationDto.Id, out JobApplication? jobApplication);
				if (jobApplication is null) { continue; }
               
                await Approve(
                    jobApplication, 
                    jobApplicationDto.ConcurrencyStamp,
                    cancellationToken);
			}
		}

		[Authorize(RockITSharedPermissions.JobApplications.Edit)]
        public virtual async Task RejectAsync(Guid id, CancellationToken cancellationToken = default)
        {
            var jobApplication = await _jobApplicationRepository.GetAsync(id: id, cancellationToken: cancellationToken);           
            if (jobApplication.Status != Enums.JobApplicationStatus.Pending)
            {
                return;
            }

            // set status as rejected
            jobApplication.Status = Enums.JobApplicationStatus.Rejected;
            jobApplication.StatusUpdate = DateTime.UtcNow;
            jobApplication.RejectEmailStatus = Enums.SyncStatus.Synced;
            jobApplication.RejectEmailStatusUpdate = DateTime.UtcNow;

            await _jobApplicationRepository.UpdateAsync(entity: jobApplication, cancellationToken: cancellationToken);

            _logger.LogInformation("Set job application:{0} status as rejected", id);
        }

		[Authorize]
		public virtual async Task<IRemoteStreamContent> GetFileByTypeAsync(GetJobApplicationFileInput input)
		{
			var jobApplication = await _jobApplicationRepository.GetAsync(input.JobApplicationId);
			if (jobApplication == null)
			{
				throw new EntityNotFoundException("Job application does not exists");
			}

            Stream stream = Stream.Null;
            string fileName = string.Empty;
            string extension = string.Empty;

            if (input.FileType.Equals("CV") 
                && !string.IsNullOrWhiteSpace(jobApplication.CVUrl))
			{
                extension = Path.GetExtension(jobApplication.CVUrl);
                fileName = $"Application_{input.JobApplicationId:N}_CV{extension}";
				stream = await _jobApplicantContainer.GetAsync(jobApplication.CVUrl);
			}
			else if (input.FileType.Equals("CoverLetter") 
                && !string.IsNullOrWhiteSpace(jobApplication.CoverLetterUrl))
			{
                extension = Path.GetExtension(jobApplication.CoverLetterUrl);
                fileName = $"Application_{input.JobApplicationId:N}_Cover_Letter{extension}";
                stream = await _jobApplicantContainer.GetAsync(jobApplication.CoverLetterUrl);
            }
            else if (input.FileType.Equals("AdditionalDocument")
                && !string.IsNullOrWhiteSpace(jobApplication.AdditionalDocumentUrl))
			{
                extension = Path.GetExtension(jobApplication.AdditionalDocumentUrl);
                fileName = $"Application_{input.JobApplicationId:N}_Additional_Document{extension}";
                stream = await _jobApplicantContainer.GetAsync(jobApplication.AdditionalDocumentUrl);
            }
			else if (input.FileType.Equals("Response")
				&& !string.IsNullOrWhiteSpace(jobApplication.ResponseUrl))
			{
				extension = Path.GetExtension(jobApplication.ResponseUrl);
				fileName = $"Application_{input.JobApplicationId:N}_Respone{extension}";
				stream = await _jobApplicantContainer.GetAsync(jobApplication.ResponseUrl);
			}

            var contentType = FileUtils.GetContentType(extension);

			return new RemoteStreamContent(stream, fileName, contentType);
        }

		private async Task Approve(
            JobApplication jobApplication,
            string? concurrencyStamp,
            CancellationToken cancellationToken)
		{
            if (!string.IsNullOrWhiteSpace(concurrencyStamp) &&
                !string.Equals(jobApplication.ConcurrencyStamp, concurrencyStamp, StringComparison.Ordinal))
            {
                throw new AbpDbConcurrencyException(typeof(JobApplication), jobApplication.Id);
            }

            try
            {
                await _externalCompanyService.SendVacancyDataAsync(jobApplication.VacancyId, cancellationToken);
                await _externalCompanyService.SendApplicantDataAsync(jobApplication.Id, cancellationToken);

                if (!string.IsNullOrWhiteSpace(jobApplication.CVUrl)
                    || !string.IsNullOrWhiteSpace(jobApplication.CoverLetterUrl)
                    || !string.IsNullOrWhiteSpace(jobApplication.AdditionalDocumentUrl))
                {
                    await _externalCompanyService.SendApplicantDocuments(jobApplication.Id, cancellationToken);
                }
            }
            catch (EzekiaSyncException ex)
            {
                _logger.LogWarning(ex, "Failed to synchronise job application {JobApplicationId} with Ezekia", jobApplication.Id);
                throw new UserFriendlyException(
                    $"Candidate approval failed. Reference log {ex.LogId} at {ex.TimestampUtc:O} (UTC).",
                    ex.Message);
            }

            jobApplication = await _jobApplicationRepository.GetAsync(jobApplication.Id, cancellationToken: cancellationToken);

            jobApplication.Status = JobApplicationStatus.Approved;
            jobApplication.StatusUpdate = Clock.Now;

            await _jobApplicationRepository.UpdateAsync(jobApplication, cancellationToken: cancellationToken);
            _logger.LogInformation("Set job application:{JobApplicationId} status as approved", jobApplication.Id);
		}

		private async Task<string?> GetResponseUrl(
            Vacancy vacancy,
            string response)
        {
            if (vacancy.VacancyFormDefinitionId is null || string.IsNullOrWhiteSpace(response)) { return null; }

            var formDefinition = await _formDefinitionRepository.FindAsync((Guid)vacancy.VacancyFormDefinitionId);
            if (formDefinition is null || string.IsNullOrWhiteSpace(formDefinition.FormDetails)) { return null; }

            var dto = new JobResponsePdfDto
            {
                Survey = JsonSerializer.Deserialize<SurveyDto>(formDefinition.FormDetails, _jsonSerializerOptions.Value)!,
                ElementNameResponsePairs = JsonSerializer.Deserialize<Dictionary<string, object>>(response, _jsonSerializerOptions.Value)!
            };

            var html = await _templateRenderer.RenderAsync(TemplateNames.JobResponsePdf, dto);
            var bytes = _htmlToPdfConverter.Convert(html);
			var url = $"{vacancy.Id}/{JobFileType.Response}_{Guid.NewGuid()}.pdf";
			await _jobApplicantContainer.SaveAsync(url, bytes);

			return url;
		}

		private JsonSerializerOptions CreateSerializerOptions()
		{
			var options = new JsonSerializerOptions(JsonSerializerDefaults.Web)
            {
                UnknownTypeHandling = JsonUnknownTypeHandling.JsonNode
            };
			
            return options;
		}
	}
}

